<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2196f3">
  <link rel="manifest" href="https://piecesnbits.github.io/zoekmap/manifest.json">
  <title>Historic Map Viewer — Favorites + Editable Shapes</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.css" />
  <script src="https://unpkg.com/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,sans-serif;background:#f4f4f4;overflow:hidden}
    #map{height:100%;width:100%}
    .menu-btn{position:absolute;top:15px;left:15px;z-index:1100;background:#0078ff;color:#fff;border:0;padding:8px 12px;border-radius:6px;cursor:pointer;box-shadow:0 3px 8px rgba(0,0,0,.2);font-weight:500}
    .menu-btn.hidden{opacity:0;pointer-events:none}
    .drawer{position:absolute;top:0;left:0;height:100%;width:320px;background:rgba(255,255,255,.97);box-shadow:2px 0 10px rgba(0,0,0,.2);backdrop-filter:blur(8px);transform:translateX(-100%);transition:transform .3s;z-index:1200;display:flex;flex-direction:column;padding:16px}
    .drawer.open{transform:translateX(0)}
    .drawer h2{margin:0 0 8px;font-weight:600}
    .close-btn{position:absolute;top:10px;right:12px;background:none;border:0;font-size:20px;color:#555;cursor:pointer}
    .section{margin-bottom:16px;border-bottom:1px solid #ddd;padding-bottom:10px}
    .favorites{list-style:none;padding:0;margin:8px 0;max-height:220px;overflow:auto}
    .fav-row{display:flex;align-items:center;justify-content:space-between;background:rgba(0,0,0,.04);padding:6px 8px;border-radius:6px;margin-bottom:6px}
    .fav-left{display:flex;gap:8px;align-items:center}
    .fav-name{cursor:pointer;font-weight:500}
    .fav-actions{display:flex;gap:6px;align-items:center}
    .btn-small{padding:4px 8px;border-radius:6px;border:0;cursor:pointer;font-size:13px}
    .btn-edit{background:#ffd966}
    .btn-delete{background:none;color:#c00}
    .btn-save{background:#28a745;color:#fff;border:0;padding:8px 10px;border-radius:6px;cursor:pointer}
    .drawer-footer{margin-top:auto;display:flex;align-items:center;justify-content:space-between;font-size:14px}
    .controls-inline{display:flex;gap:6px;align-items:center}
    .notice{font-size:13px;color:#666}
    .edit-banner{background:#fff3cd;padding:8px;border-radius:6px;border:1px solid #ffeeba;margin-bottom:8px}
  </style>
</head>
<body>
  <button id="menuBtn" class="menu-btn">☰ Menu</button>

  <div id="drawer" class="drawer" role="region" aria-label="Map controls">
    <button class="close-btn" id="closeDrawerBtn">✕</button>
    <h2>Map Controls</h2>

    <div class="section">
      <h3>Base Layers</h3>
      <div class="layer-item">
        <label><input type="radio" name="baseLayer" value="google" checked /> Google Hybrid</label>
      </div>
    </div>

    <div class="section">
      <h3>Overlays</h3>
      <div class="layer-item">
        <label><input type="checkbox" id="ferrarisToggle" checked /> Ferraris Overlay</label>
        <input id="opacitySliderFerraris" class="slider" type="range" min="0" max="1" step="0.1" value="0.7" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="grbToggle" /> GRB Overlay</label>
        <input id="opacitySliderGRB" class="slider" type="range" min="0" max="1" step="0.1" value="0.7" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="hillshadeToggle" /> Hillshade Overlay</label>
        <input id="opacitySliderHillshade" class="slider" type="range" min="0" max="1" step="0.1" value="0.7" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="autoPanToggle" /> Auto-pan location</label>
      </div>
    </div>

    <div class="section">
      <h3>⭐ Favorites</h3>
      <div style="display:flex;gap:8px;margin-bottom:8px">
        <button id="saveFavBtn" class="btn-save" style="flex:1">Save Current View</button>
        <button id="exportBtn" class="btn-small" title="Export favorites">Export</button>
      </div>

      <div id="editBanner" style="display:none" class="edit-banner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong id="editingFavName">Editing</strong></div>
          <div class="controls-inline">
            <button id="saveChangesBtn" class="btn-small btn-save">Save changes</button>
            <button id="cancelEditBtn" class="btn-small">Cancel</button>
          </div>
        </div>
        <div class="notice">You're editing shapes for this favorite. Switching favorites will ask to discard changes.</div>
      </div>

      <ul id="favoritesList" class="favorites" aria-live="polite"></ul>
    </div>

    <div class="drawer-footer">
      <div>
        <label for="darkModeToggle">Dark mode</label>
        <input type="checkbox" id="darkModeToggle" />
      </div>
      <div class="notice">Tip: Draw shapes, open a favorite, edit & save.</div>
    </div>
  </div>

  <div id="map"></div>

  <script>
  // ====== DrawingManager ======
  class DrawingManager {
    constructor(map) {
      this.map = map;
      this.drawnItems = new L.FeatureGroup();
      this.map.addLayer(this.drawnItems);

      // Default draw control: drawing allowed, edit disabled.
      this.drawControl = new L.Control.Draw({
        position: 'topright',
        draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: true },
        edit: false
      });
      this.map.addControl(this.drawControl);

      // Edit-enabled control will be created on demand.
      this.editControl = null;

      // Events
      this.map.on(L.Draw.Event.CREATED, (e) => this.onCreated(e));
    }

    onCreated(event) {
      this.drawnItems.addLayer(event.layer);
    }

    clear() {
      this.drawnItems.clearLayers();
    }

    loadGeoJSON(geojson) {
      this.clear();
      if (!geojson || !geojson.features || !geojson.features.length) return;
      L.geoJSON(geojson, {
        pointToLayer: (feature, latlng) => L.marker(latlng)
      }).eachLayer(layer => this.drawnItems.addLayer(layer));
    }

    toGeoJSON() {
      return this.drawnItems.toGeoJSON();
    }

    enableEditMode() {
      // If already in edit mode, no-op
      if (this.editControl) return;

      // Remove the default drawControl and replace with one that has edit enabled
      if (this.drawControl) this.map.removeControl(this.drawControl);

      this.editControl = new L.Control.Draw({
        position: 'topright',
        draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: true },
        edit: { featureGroup: this.drawnItems, remove: true }
      });
      this.map.addControl(this.editControl);

      // Bind edit events if needed (optional hooks)
      // We rely on the draw.edit toolbar for editing/removing features.
    }

    disableEditMode() {
      if (this.editControl) {
        this.map.removeControl(this.editControl);
        this.editControl = null;
      }
      // restore default drawControl (draw-only, edit disabled)
      if (!this.drawControl) {
        this.drawControl = new L.Control.Draw({
          position: 'topright',
          draw: { polygon: true, polyline: false, rectangle: false, circle: false, marker: true },
          edit: false
        });
        this.map.addControl(this.drawControl);
      }
    }
  }

  // ====== FavoriteManager ======
  class FavoriteManager {
    constructor(map, drawingManager, listElement) {
      this.map = map;
      this.drawingManager = drawingManager;
      this.listElement = listElement;
      this.storageKey = 'favorites';
      this.data = [];
      this.markers = [];
      this.activeIndex = null; // currently loaded favorite index (view)
      this.editIndex = null;   // currently editing favorite index
      this.load();
    }

    load() {
      try {
        const stored = JSON.parse(localStorage.getItem(this.storageKey) || '[]');
        this.data = stored;
      } catch (err) {
        console.error('Failed to parse favorites', err);
        this.data = [];
      }
      this._renderList();

    }

    saveStorage() {
      localStorage.setItem(this.storageKey, JSON.stringify(this.data));
    }

    addFavorite(name) {
      const center = this.map.getCenter();
      const zoom = this.map.getZoom();
      const shapes = this.drawingManager.toGeoJSON();
      const fav = { name, center, zoom, shapes };
      this.data.push(fav);
      this.saveStorage();
      this._renderList();

      this.drawingManager.clear();
    }

    deleteFavorite(index) {
      // if deleting the favorite being edited, cancel edit
      if (this.editIndex === index) {
        this.cancelEdit();
      }
      this.data.splice(index, 1);
      this.saveStorage();
      this._renderList();
      this.drawingManager.clear();

      // fix active/edit indices if needed
      if (this.activeIndex === index) this.activeIndex = null;
      if (this.editIndex === index) this.editIndex = null;
    }

    // Load favorite into view (no edit)
    openFavorite(index, options = { confirmDiscard: true }) {
      // If currently editing a favourite and it's not the same, ask confirm
      if (this.editIndex !== null && this.editIndex !== index && options.confirmDiscard) {
        const discard = confirm('You have unsaved edits. Discard changes?');
        if (!discard) return false;
        this.cancelEdit(); // discard changes
      }

      const fav = this.data[index];
      if (!fav) return false;
      this.map.setView(fav.center, fav.zoom);
      this.activeIndex = index;

      // Clear drawn shapes (we are not entering edit mode, but show shapes as non-editable)
      this.drawingManager.loadGeoJSON(fav.shapes || { type: 'FeatureCollection', features: [] });
      // When not editing we want draw controls active for creating new temp shapes,
      // but ensure edit mode is disabled:
      this.drawingManager.disableEditMode();
      return true;
    }

    // Enter edit mode for a given favorite
    enterEditMode(index) {
      const fav = this.data[index];
      if (!fav) return false;
      this.map.setView(fav.center, fav.zoom);
      // If already editing a different index, ask confirm
      if (this.editIndex !== null && this.editIndex !== index) {
        const discard = confirm('You have unsaved edits. Discard changes?');
        if (!discard) return false;
        this.cancelEdit();
      }

      this.editIndex = index;
      // Load shapes into drawn layer so user can edit them.
      this.drawingManager.loadGeoJSON(fav.shapes || { type: 'FeatureCollection', features: [] });
      this.drawingManager.enableEditMode();
      return true;
    }

    // Save edited shapes back to the currently edited favourite (only shapes)
    saveEditedShapes() {
      if (this.editIndex === null) return false;
      const shapes = this.drawingManager.toGeoJSON();
      // overwrite shapes only; keep center/zoom as-is
      this.data[this.editIndex].shapes = shapes;
      this.saveStorage();
      this._renderList();
      // exit edit mode
      this.cancelEdit();
      return true;
    }

    // Cancel current edit (discard changes)
    cancelEdit() {
      if (this.editIndex === null) return;
      // Reload shapes from storage for the favourite or clear
      const fav = this.data[this.editIndex];
      if (fav && fav.shapes) {
        this.drawingManager.loadGeoJSON(fav.shapes);
      } else {
        this.drawingManager.clear();
      }
      this.editIndex = null;
      this.drawingManager.disableEditMode();
    }

    _renderList() {
      this.listElement.innerHTML = '';
      this.data.forEach((fav, i) => {
        const li = document.createElement('li');
        li.className = 'fav-row';

        const left = document.createElement('div');
        left.className = 'fav-left';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'fav-name';
        nameSpan.textContent = fav.name;
        nameSpan.title = 'Open favorite (view only)';
        nameSpan.addEventListener('click', () => this.openFavorite(i, { confirmDiscard: true }));

        left.appendChild(nameSpan);

        const right = document.createElement('div');
        right.className = 'fav-actions';

        const editBtn = document.createElement('button');
        editBtn.className = 'btn-small btn-edit';
        editBtn.textContent = 'Edit';
        editBtn.title = 'Edit shapes in this favorite';
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          UIManager.showEditBanner(this.data[i].name);
          this.enterEditMode(i);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn-small btn-delete';
        deleteBtn.textContent = '✕';
        deleteBtn.title = 'Delete favorite';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (confirm(`Delete favorite "${fav.name}"?`)) {
            this.deleteFavorite(i);
          }
        });

        right.appendChild(editBtn);
        right.appendChild(deleteBtn);

        li.appendChild(left);
        li.appendChild(right);
        this.listElement.appendChild(li);
      });
    }

    exportJSON() {
      return JSON.stringify(this.data, null, 2);
    }
  }

  // ====== UIManager (wires UI to managers) ======
  const UIManager = (function() {
    let favManager = null;
    let drawingManager = null;

    const cache = {
      drawer: document.getElementById('drawer'),
      menuBtn: document.getElementById('menuBtn'),
      closeDrawerBtn: document.getElementById('closeDrawerBtn'),
      saveFavBtn: document.getElementById('saveFavBtn'),
      favoritesList: document.getElementById('favoritesList'),
      editBanner: document.getElementById('editBanner'),
      editingFavName: document.getElementById('editingFavName'),
      saveChangesBtn: document.getElementById('saveChangesBtn'),
      cancelEditBtn: document.getElementById('cancelEditBtn'),
      exportBtn: document.getElementById('exportBtn'),
      darkModeToggle: document.getElementById('darkModeToggle'),
      ferrarisToggle: document.getElementById('ferrarisToggle'),
      grbToggle: document.getElementById('grbToggle'),
      hillshadeToggle: document.getElementById('hillshadeToggle'),
      opacitySliderFerraris: document.getElementById('opacitySliderFerraris'),
      opacitySliderGRB: document.getElementById('opacitySliderGRB'),
      opacitySliderHillshade: document.getElementById('opacitySliderHillshade'),
      autoPanToggle: document.getElementById('autoPanToggle'),
      saveFavBtnEl: null
    };

    function init(managers) {
      favManager = managers.favManager;
      drawingManager = managers.drawingManager;

      // drawer open/close
      cache.menuBtn.addEventListener('click', () => { cache.drawer.classList.add('open'); cache.menuBtn.classList.add('hidden'); });
      cache.closeDrawerBtn.addEventListener('click', () => { cache.drawer.classList.remove('open'); cache.menuBtn.classList.remove('hidden'); });

      // Save current view (create new favorite)
      cache.saveFavBtn.addEventListener('click', () => {
        const name = prompt('Enter a name for this location:');
        if (!name) return;
        favManager.addFavorite(name);
      });

      // Save changes (only while editing)
      cache.saveChangesBtn.addEventListener('click', () => {
        favManager.saveEditedShapes();
        hideEditBanner();
      });

      cache.cancelEditBtn.addEventListener('click', () => {
        if (!confirm('Discard edits?')) return;
        favManager.cancelEdit();
        hideEditBanner();
      });

      // Export favorites JSON to clipboard
      cache.exportBtn.addEventListener('click', async () => {
        try {
          const json = favManager.exportJSON();
          await navigator.clipboard.writeText(json);
          alert('Favorites JSON copied to clipboard.');
        } catch (err) {
          alert('Export failed: ' + (err && err.message ? err.message : err));
        }
      });

      // dark mode
      cache.darkModeToggle.addEventListener('change', e => {
        cache.drawer.classList.toggle('dark', e.target.checked);
        document.body.style.background = e.target.checked ? '#1e1e1e' : '#f4f4f4';
      });
    }

    function showEditBanner(name) {
      cache.editBanner.style.display = 'block';
      cache.editingFavName.textContent = 'Editing: ' + name;
    }

    function hideEditBanner() {
      cache.editBanner.style.display = 'none';
      cache.editingFavName.textContent = '';
    }

    return { init, showEditBanner, hideEditBanner };
  })();

  // ====== Map initialization and wiring everything ======
  const map = L.map('map').setView([50.85, 4.35], 8);

  const googleHybrid = L.tileLayer(
    'https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',
    { subdomains: ['mt0','mt1','mt2','mt3'], attribution: '© Google' }
  ).addTo(map);

  const ferraris = L.tileLayer(
    'https://geo.api.vlaanderen.be/HISTCART/wmts?service=WMTS&request=GetTile&version=1.0.0&layer=ferraris&style=&tilematrixset=GoogleMapsVL&format=image/png&tilematrix={z}&tilerow={y}&tilecol={x}',
    { attribution: '© Vlaanderen', opacity: 0.7 }
  ).addTo(map);

  const grb = L.tileLayer(
    'https://geo.api.vlaanderen.be/GRB/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=grb_bsk&STYLE=&TILEMATRIXSET=GoogleMapsVL&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png',
    { attribution: '© Vlaanderen GRB', opacity: 0.7 }
  );

  const hillshade = L.tileLayer(
  'https://geo.api.vlaanderen.be/DHMV/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0' +
  '&LAYER=DHMV_II_HILL_25cm&STYLE=&TILEMATRIXSET=GoogleMapsVL' +
  '&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png',
  { attribution: '© Vlaanderen DHMV II', opacity: 0.7 }
);

  map.zoomControl.setPosition('bottomright');

const geocoder = L.Control.geocoder({
  defaultMarkGeocode: false,
  placeholder: 'Search location...',
  errorMessage: 'Not found'
})
.on('markgeocode', function(e) {
  map.setView(e.geocode.center, 16); // no marker added
})
.addTo(map);

  const drawingManager = new DrawingManager(map);
  const favManager = new FavoriteManager(map, drawingManager, document.getElementById('favoritesList'));

  UIManager.init({ favManager, drawingManager });

  // wire overlay toggles and opacity sliders
  document.getElementById('ferrarisToggle').addEventListener('change', e => e.target.checked ? ferraris.addTo(map) : map.removeLayer(ferraris));
  document.getElementById('grbToggle').addEventListener('change', e => e.target.checked ? grb.addTo(map) : map.removeLayer(grb));
  document.getElementById('hillshadeToggle').addEventListener('change', e => e.target.checked ? hillshade.addTo(map) : map.removeLayer(hillshade));
  document.getElementById('opacitySliderFerraris').addEventListener('input', e => ferraris.setOpacity(e.target.value));
  document.getElementById('opacitySliderGRB').addEventListener('input', e => grb.setOpacity(e.target.value));
  document.getElementById('opacitySliderHillshade').addEventListener('input', e => hillshade.setOpacity(e.target.value));

  // Auto-pan logic
  let userMarker = null;
  let autoPan = false;
  const autoPanToggle = document.getElementById('autoPanToggle');
  autoPanToggle.addEventListener('change', e => autoPan = e.target.checked);

  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(pos => {
      const latlng = [pos.coords.latitude, pos.coords.longitude];
      if (!userMarker) userMarker = L.circleMarker(latlng, { radius: 7, color: '#0078ff', fillColor: '#0078ff', fillOpacity: .9 }).addTo(map);
      else userMarker.setLatLng(latlng);
      if (autoPan) map.setView(latlng);
    }, err => console.warn(err), { enableHighAccuracy: true, maximumAge: 1000 });
  }
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('https://piecesnbits.github.io/zoekmap/sw.js')
      .then(() => console.log('Service Worker registered'))
      .catch(err => console.error('Service Worker registration failed:', err));
  }
  </script>
</body>
</html>

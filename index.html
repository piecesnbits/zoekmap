<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2196f3">
  <link rel="shortcut icon" href="/zoekmap/favicon.ico" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="manifest" href="https://piecesnbits.github.io/zoekmap/manifest.json?v=2" />
  <title>Zoekmap</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.css" />
  <script src="https://unpkg.com/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: Inter, system-ui, sans-serif;
      background: #f4f4f4;
      overflow: hidden
    }

    #map {
      height: 100%;
      width: 100%
    }

    .layer-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0
    }

    .layer-select {
      width: 100%;
      padding: 6px;
      font-size: 15px;
    }

    .layer-select option {
      padding-left: 28px;
      background-size: 24px 24px;
      background-position: 2px center;
      background-repeat: no-repeat;
    }

    .slider {
      width: 120px;
      margin-left: 8px
    }

    .menu-btn {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 1100;
      background: #0078ff;
      color: #fff;
      border: 0;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      box-shadow: 0 3px 8px rgba(0, 0, 0, .2);
      font-weight: 500
    }

    .menu-btn.hidden {
      opacity: 0;
      pointer-events: none
    }

    .drawer {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 320px;
      background: rgba(255, 255, 255, .97);
      box-shadow: 2px 0 10px rgba(0, 0, 0, .2);
      backdrop-filter: blur(8px);
      transform: translateX(-100%);
      transition: transform .3s;
      z-index: 1200;
      display: flex;
      flex-direction: column;
      padding: 16px
    }

    .drawer.open {
      transform: translateX(0)
    }

    .drawer h2 {
      margin: 0 0 8px;
      font-weight: 600
    }

    .close-btn {
      position: absolute;
      top: 10px;
      right: 12px;
      background: none;
      border: 0;
      font-size: 20px;
      color: #555;
      cursor: pointer
    }

    .section {
      margin-bottom: 16px;
      border-bottom: 1px solid #ddd;
      padding-bottom: 10px
    }

    .favorites {
      list-style: none;
      padding: 0;
      margin: 8px 0;
      max-height: 220px;
      overflow: auto
    }

    .fav-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0, 0, 0, .04);
      padding: 6px 8px;
      border-radius: 6px;
      margin-bottom: 6px
    }

    .fav-left {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .fav-name {
      cursor: pointer;
      font-weight: 500
    }

    .fav-actions {
      display: flex;
      gap: 6px;
      align-items: center
    }

    .btn-small {
      padding: 4px 8px;
      border-radius: 6px;
      border: 0;
      cursor: pointer;
      font-size: 16px;
      /* slightly larger for emoji icons */
      line-height: 1;
    }

    .btn-delete {
      background: none;
      color: #c00
    }

    .btn-save {
      background: #28a745;
      color: #fff;
      border: 0;
      padding: 8px 10px;
      border-radius: 6px;
      cursor: pointer
    }

    .drawer-footer {
      margin-top: 0px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 14px
    }

    .controls-inline {
      display: flex;
      gap: 6px;
      align-items: center
    }

    .notice {
      font-size: 13px;
      color: #666
    }

    .edit-banner {
      background: #fff3cd;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #ffeeba;
      margin-bottom: 8px
    }
  </style>
</head>

<body>
  <button id="menuBtn" class="menu-btn">‚ò∞ Menu</button>

  <div id="drawer" class="drawer" role="region" aria-label="Map controls">
    <button class="close-btn" id="closeDrawerBtn">‚úï</button>
    <h2>Map Controls</h2>

    <div class="section">
      <h3>üåç Base Layers</h3>

      <select id="base-layer-select" class="layer-select">
      </select>
    </div>

    <div class="section">
      <h3>üó∫Ô∏è Overlays</h3>
      <div class="layer-item">
        <label><input type="checkbox" id="ferrarisToggle" checked /> Ferraris</label>
        <input id="opacitySliderFerraris" class="slider" type="range" min="0" max="1" step="0.1" value="1.0" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="grbToggle" /> GRB</label>
        <input id="opacitySliderGRB" class="slider" type="range" min="0" max="1" step="0.1" value="1.0" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="hillshadeToggle" /> Hillshade</label>
        <input id="opacitySliderHillshade" class="slider" type="range" min="0" max="1" step="0.1" value="1.0" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="dhmvToggle" /> dhmv</label>
        <input id="opacitySliderDhmv" class="slider" type="range" min="0" max="1" step="0.1" value="1.0" />
      </div>
      <div class="layer-item">
        <label><input type="checkbox" id="autoPanToggle" /> Auto-pan location</label>
      </div>
    </div>

    <div class="section">
      <h3>‚≠ê Favorites</h3>
      <div style="display:flex;gap:8px;margin-bottom:8px">
        <button id="newViewBtn" class="btn-save" style="flex:1">Create New View</button>
        <div id="saveCancelWrapper" style="display:none;flex:1;gap:6px">
          <button id="saveNewViewBtn" class="btn-save" style="flex:1">Save</button>
          <button id="cancelNewViewBtn" class="btn-small" style="flex:1">Cancel</button>
        </div>
      </div>

      <div id="editBanner" style="display:none" class="edit-banner">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><strong id="editingFavName">Editing</strong></div>
          <div class="controls-inline">
            <button id="saveChangesBtn" class="btn-small btn-save">Save changes</button>
            <button id="cancelEditBtn" class="btn-small">Cancel</button>
          </div>
        </div>
        <div class="notice">You're editing shapes for this favorite. Switching favorites will ask to discard changes.
        </div>
      </div>

      <ul id="favoritesList" class="favorites" aria-live="polite"></ul>
    </div>

    <div class="drawer-footer">

    </div>
  </div> <!-- closes .drawer -->


  <div id="map"></div>

  <script>

    class BaseLayerController {
      constructor(map, selectId) {
        this.map = map;
        this.select = document.getElementById(selectId);
        this.baseLayers = {};
        this.activeBase = null;

        this.select.addEventListener("change", () => {
          this.setBase(this.select.value);
        });
      }

      addBase(key, config) {
        this.baseLayers[key] = config.tileLayer;

        const option = document.createElement("option");
        option.value = key;
        option.textContent = config.label;

        if (config.icon) {
          option.style.backgroundImage = `url(${config.icon})`;
        }

        this.select.appendChild(option);

        if (!this.activeBase) {
          this.setBase(key);
        }
      }

      setBase(key) {
        const layer = this.baseLayers[key];
        if (!layer) return;

        if (this.activeBase) {
          this.map.removeLayer(this.activeBase);
        }

        layer.addTo(this.map);
        this.activeBase = layer;
      }
    }


    class UserLocationMarker {
      constructor(map) {
        this.map = map;
        this.marker = null;
        this.lastPosition = null;

        this._createPane();
        this._injectStyles();
      }

      _createPane() {
        if (!this.map.getPane('userLocationPane')) {
          this.map.createPane('userLocationPane');
          const pane = this.map.getPane('userLocationPane');
          pane.style.zIndex = 600;
          pane.style.pointerEvents = 'none';
        }
      }

      updatePosition(lat, lng) {
        const latlng = [lat, lng];
        this.lastPosition = latlng;

        if (!this.marker) {
          this.marker = L.marker(latlng, {
            pane: 'userLocationPane',
            icon: L.divIcon({
              className: 'user-pulse-marker',
              iconSize: [20, 20],
              iconAnchor: [10, 10]
            })
          }).addTo(this.map);
        } else {
          this.marker.setLatLng(latlng);
        }
      }

      _injectStyles() {
        if (document.getElementById('pulse-style')) return;

        const css = `
      .user-pulse-marker {
        position: relative;
      }
      .user-pulse-marker::before {
        content: "";
        width: 14px;
        height: 14px;
        background: #4285f4;
        border-radius: 50%;
        border: 1px solid #fff;
        position: absolute;
        top: 3px;
        left: 3px;
        box-shadow: 0 0 6px rgba(66,133,244,0.6);
      }
      .user-pulse-marker::after {
        content: "";
        width: 15px;
        height: 15px;
        background: rgba(66,133,244,0.4);
        border-radius: 50%;
        position: absolute;
        top: 3px;
        left: 3px;
        animation: user-pulse 1.6s ease-out infinite;
      }
      @keyframes user-pulse {
        0% { transform: scale(1); opacity: 0.9; }
        100% { transform: scale(2.8); opacity: 0; }
      }
    `;

        const style = document.createElement('style');
        style.id = 'pulse-style';
        style.textContent = css;
        document.head.appendChild(style);
      }
    }


    class ShareManager {
      static compress(obj) {
        return LZString.compressToEncodedURIComponent(JSON.stringify(obj));
      }

      static decompress(str) {
        try {
          return JSON.parse(LZString.decompressFromEncodedURIComponent(str));
        } catch {
          return null;
        }
      }

      static generateShareURL(favObj) {
        const payload = this.compress(favObj);
        const url = new URL(window.location.href);
        url.searchParams.set('favdata', payload);
        return url.toString();
      }

      static loadSharedFavorite() {
        const params = new URLSearchParams(window.location.search);
        const data = params.get('favdata');
        if (!data) return null;
        return this.decompress(data);
      }
    }

// ====== DrawingManager ======
class DrawingManager {
  constructor(map) {
    this.map = map;

    // Create a dedicated pane for drawings (above overlays)
    this.paneName = "custom-drawing-pane";
    this._ensurePane();

    // FeatureGroup with the correct pane
    this.drawnItems = new L.FeatureGroup(null, {
      pane: this.paneName
    });
    this.map.addLayer(this.drawnItems);

    // Draw controls
    this.drawControl = new L.Control.Draw({
      position: 'topright',
      draw: {
        polygon: true,
        polyline: false,
        rectangle: false,
        circle: false,
        marker: true
      },
      edit: false
    });

    this.editControl = null;

    // Handle new drawings
    this.map.on(L.Draw.Event.CREATED, (e) => this.onCreated(e));
  }

  _ensurePane() {
    if (!this.map.getPane(this.paneName)) {
      const pane = this.map.createPane(this.paneName);
      pane.style.zIndex = 700;  // Above overlays
      pane.style.pointerEvents = "auto";
    }
  }

  onCreated(event) {
    const layer = event.layer;
    layer.options.pane = this.paneName; // Force layer into drawing pane
    this.drawnItems.addLayer(layer);
  }

  clear() {
    this.drawnItems.clearLayers();
  }

  loadGeoJSON(geojson) {
    this.clear();
    if (!geojson || !geojson.features?.length) return;

    L.geoJSON(geojson, {
      pane: this.paneName,
      pointToLayer: (feature, latlng) =>
        L.marker(latlng, { pane: this.paneName })
    }).eachLayer(layer => this.drawnItems.addLayer(layer));
  }

  toGeoJSON() {
    return this.drawnItems.toGeoJSON();
  }

  enableEditMode() {
    if (this.editControl) return;

    if (this.drawControl) this.map.removeControl(this.drawControl);

    this.editControl = new L.Control.Draw({
      position: 'topright',
      draw: {
        polygon: true,
        polyline: false,
        rectangle: false,
        circle: false,
        marker: true
      },
      edit: {
        featureGroup: this.drawnItems,
        remove: true
      }
    });

    this.map.addControl(this.editControl);
  }

  disableEditMode() {
    if (this.editControl) {
      this.map.removeControl(this.editControl);
      this.editControl = null;
    }

    if (!this.drawControl) {
      this.drawControl = new L.Control.Draw({
        position: 'topright',
        draw: {
          polygon: true,
          polyline: false,
          rectangle: false,
          circle: false,
          marker: true
        },
        edit: false
      });
    }

    this.map.addControl(this.drawControl);
  }
}


    // ====== FavoriteManager ======
    class FavoriteManager {
      constructor(map, drawingManager, listElement) {
        this.map = map;
        this.drawingManager = drawingManager;
        this.listElement = listElement;
        this.storageKey = 'favorites';
        this.data = [];
        this.activeIndex = null;
        this.editIndex = null;
        this.load();
      }

      load() {
        try { this.data = JSON.parse(localStorage.getItem(this.storageKey) || '[]'); }
        catch { this.data = []; }
        this._renderList();
      }

      saveStorage() {
        localStorage.setItem(this.storageKey, JSON.stringify(this.data));
      }

      addFavorite(name) {
        const center = this.map.getCenter();
        const zoom = this.map.getZoom();
        const shapes = this.drawingManager.toGeoJSON();
        this.data.push({ name, center, zoom, shapes });
        this.saveStorage();
        this._renderList();
        this.drawingManager.clear();
      }

      deleteFavorite(index) {
        if (this.editIndex === index) this.cancelEdit();
        this.data.splice(index, 1);
        this.saveStorage();
        this._renderList();
        this.drawingManager.clear();
        if (this.activeIndex === index) this.activeIndex = null;
        if (this.editIndex === index) this.editIndex = null;
      }

      openFavorite(index, options = { confirmDiscard: true }) {
        if (this.editIndex !== null && this.editIndex !== index && options.confirmDiscard) {
          if (!confirm('You have unsaved edits. Discard changes?')) return false;
          this.cancelEdit();
        }
        const fav = this.data[index];
        if (!fav) return false;
        this.map.setView(fav.center, fav.zoom);
        this.activeIndex = index;
        this.drawingManager.loadGeoJSON(fav.shapes || { type: 'FeatureCollection', features: [] });
        this.drawingManager.disableEditMode();
        return true;
      }

      enterEditMode(index) {
        const fav = this.data[index];
        if (!fav) return false;
        this.map.setView(fav.center, fav.zoom);
        if (this.editIndex !== null && this.editIndex !== index) {
          if (!confirm('You have unsaved edits. Discard changes?')) return false;
          this.cancelEdit();
        }
        this.editIndex = index;
        this.drawingManager.loadGeoJSON(fav.shapes || { type: 'FeatureCollection', features: [] });
        this.drawingManager.enableEditMode();
        return true;
      }

      saveEditedShapes() {
        if (this.editIndex === null) return false;
        const shapes = this.drawingManager.toGeoJSON();
        this.data[this.editIndex].shapes = shapes;
        this.saveStorage();
        this._renderList();
        this.cancelEdit();
        return true;
      }

      cancelEdit() {
        if (this.editIndex === null) return;
        const fav = this.data[this.editIndex];
        if (fav && fav.shapes) this.drawingManager.loadGeoJSON(fav.shapes);
        else this.drawingManager.clear();
        this.editIndex = null;
        this.drawingManager.disableEditMode();
        this.drawingManager.clear();
      }

      _renderList() {
        this.listElement.innerHTML = '';
        this.data.forEach((fav, i) => {
          const li = document.createElement('li');
          li.className = 'fav-row';

          const left = document.createElement('div');
          left.className = 'fav-left';
          const nameSpan = document.createElement('span');
          nameSpan.className = 'fav-name';
          nameSpan.textContent = fav.name;
          nameSpan.title = 'Open favorite (view only)';
          nameSpan.addEventListener('click', () => this.openFavorite(i, { confirmDiscard: true }));
          left.appendChild(nameSpan);

          const right = document.createElement('div');
          right.className = 'fav-actions';

          const editBtn = document.createElement('button');
          editBtn.className = 'btn-small';
          editBtn.innerHTML = '<span class="material-icons">edit</span>';                // pencil icon
          editBtn.title = 'Edit shapes in this favorite';

          editBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            UIManager.showEditBanner(this.data[i].name);
            this.enterEditMode(i);
          });

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'btn-small btn-delete';
          deleteBtn.innerHTML = '<span class="material-icons">close</span>';
          deleteBtn.title = 'Delete favorite';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm(`Delete favorite "${fav.name}"?`)) this.deleteFavorite(i);
          });

          const shareBtn = document.createElement('button');
          shareBtn.className = 'btn-small';
          shareBtn.innerHTML = '<span class="material-icons">share</span>';     // clean, universal share glyph
          shareBtn.title = 'Share this favorite';

          shareBtn.addEventListener('click', (e) => {
            e.stopPropagation();

            const favObj = this.data[i];
            const url = ShareManager.generateShareURL(favObj);

            if (navigator.share) {
              navigator.share({
                title: favObj.name,
                text: 'Shared via Zoekmap',
                url
              });
            } else {
              navigator.clipboard.writeText(url);
              alert('Share link copied to clipboard');
            }
          });

          right.appendChild(shareBtn);
          right.appendChild(editBtn);
          right.appendChild(deleteBtn);
          li.appendChild(left);
          li.appendChild(right);
          this.listElement.appendChild(li);
        });
      }

      exportJSON() { return JSON.stringify(this.data, null, 2); }
    }

    // ====== UIManager ======
    const UIManager = (function () {
      let favManager = null;
      let drawingManager = null;

      const cache = {
        drawer: document.getElementById('drawer'),
        menuBtn: document.getElementById('menuBtn'),
        closeDrawerBtn: document.getElementById('closeDrawerBtn'),
        newViewBtn: document.getElementById('newViewBtn'),
        saveNewViewBtn: document.getElementById('saveNewViewBtn'),
        cancelNewViewBtn: document.getElementById('cancelNewViewBtn'),
        saveCancelWrapper: document.getElementById('saveCancelWrapper'),
        favoritesList: document.getElementById('favoritesList'),
        editBanner: document.getElementById('editBanner'),
        editingFavName: document.getElementById('editingFavName'),
        saveChangesBtn: document.getElementById('saveChangesBtn'),
        cancelEditBtn: document.getElementById('cancelEditBtn')
      };

      function init(managers) {
        favManager = managers.favManager;
        drawingManager = managers.drawingManager;

        // drawer open/close
        cache.menuBtn.addEventListener('click', () => { cache.drawer.classList.add('open'); cache.menuBtn.classList.add('hidden'); });
        cache.closeDrawerBtn.addEventListener('click', () => { cache.drawer.classList.remove('open'); cache.menuBtn.classList.remove('hidden'); });

        // Create New View
        cache.newViewBtn.addEventListener('click', () => {
          drawingManager.clear();
          drawingManager.enableEditMode();
          cache.newViewBtn.style.display = 'none';
          cache.saveCancelWrapper.style.display = 'flex';
        });

        // Save New View
        cache.saveNewViewBtn.addEventListener('click', () => {
          const name = prompt('Enter a name for this view:');
          if (!name) return;
          favManager.addFavorite(name);
          drawingManager.disableEditMode();
          drawingManager.clear();
          cache.saveCancelWrapper.style.display = 'none';
          cache.newViewBtn.style.display = 'flex';
        });

        // Cancel New View
        cache.cancelNewViewBtn.addEventListener('click', () => {
          drawingManager.clear();
          drawingManager.disableEditMode();
          cache.saveCancelWrapper.style.display = 'none';
          cache.newViewBtn.style.display = 'flex';
        });

        // Save changes (only while editing)
        cache.saveChangesBtn.addEventListener('click', () => {
          favManager.saveEditedShapes();
          hideEditBanner();
        });

        cache.cancelEditBtn.addEventListener('click', () => {
          if (!confirm('Discard edits?')) return;
          favManager.cancelEdit();
          hideEditBanner();
        });

      }

      function showEditBanner(name) {
        cache.editBanner.style.display = 'block';
        cache.editingFavName.textContent = 'Editing: ' + name;
      }

      function hideEditBanner() {
        cache.editBanner.style.display = 'none';
        cache.editingFavName.textContent = '';
      }

      return { init, showEditBanner, hideEditBanner };
    })();

    // ====== Map initialization ======
    const map = L.map('map').setView([50.85, 4.35], 9);

    const baseLayerCtrl = new BaseLayerController(map, "base-layer-select");

    // 1 Google Hybrid
    baseLayerCtrl.addBase("googleHybrid", {
      label: "Google Hybrid",
      icon: "https://www.google.com/favicon.ico",
      tileLayer: L.tileLayer(
        "https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}",
        { subdomains: ["mt0", "mt1", "mt2", "mt3"], attribution: "¬© Google" }
      )
    });

    // 2 Google Satellite
    baseLayerCtrl.addBase("googleSatellite", {
      label: "Google Satellite",
      icon: "https://www.google.com/favicon.ico",
      tileLayer: L.tileLayer(
        "https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}",
        { subdomains: ["mt0", "mt1", "mt2", "mt3"], attribution: "¬© Google" }
      )
    });



    // 3 Google Terrain
    baseLayerCtrl.addBase("googleTerrain", {
      label: "Google Terrain",
      icon: "https://www.google.com/favicon.ico",
      tileLayer: L.tileLayer(
        "https://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}",
        { subdomains: ["mt0", "mt1", "mt2", "mt3"], attribution: "¬© Google" }
      )
    });

    // 4 OpenStreetMap
    baseLayerCtrl.addBase("osm", {
      label: "OpenStreetMap",
      icon: "https://www.openstreetmap.org/favicon.ico",
      tileLayer: L.tileLayer(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        { attribution: "¬© OSM contributors" }
      )
    });

    // 5 OpenTopoMap
    // baseLayerCtrl.addBase("opentopo", {
    //   label: "OpenTopoMap",
    //   icon: "https://opentopomap.org/favicon.ico",
    //   tileLayer: L.tileLayer(
    //     "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
    //     { attribution: "¬© OpenTopoMap CC-BY-SA" }
    //   )
    // });

    // 6 Carto Light
    baseLayerCtrl.addBase("cartoLight", {
      label: "Carto Light",
      icon: "https://carto.com/favicon.ico",
      tileLayer: L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
        { attribution: "¬© Carto" }
      )
    });

    // 7 Carto Dark
    baseLayerCtrl.addBase("cartoDark", {
      label: "Carto Dark",
      icon: "https://carto.com/favicon.ico",
      tileLayer: L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png",
        { attribution: "¬© Carto" }
      )
    });

    // 8 ESRI World Imagery
    baseLayerCtrl.addBase("esri", {
      label: "ESRI World Imagery",
      icon: "https://www.esri.com/favicon.ico",
      tileLayer: L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        { attribution: "Tiles ¬© Esri" }
      )
    });






    map.createPane('overlayPaneTop');
    map.getPane('overlayPaneTop').style.zIndex = 650; // above base layers (default: 200-400)
    // Define the geographic bounds of the Ferraris layer (example)
    const ferrarisBounds = [
      [50.685, 2.53],   // southwest corner (lat, lng)
      [51.520, 5.92]    // northeast corner (lat, lng)
    ];

    const ferraris = L.tileLayer(
      'https://geo.api.vlaanderen.be/HISTCART/wmts?service=WMTS&request=GetTile&version=1.0.0&layer=ferraris&style=&tilematrixset=GoogleMapsVL&format=image/png&tilematrix={z}&tilerow={y}&tilecol={x}',
      {
        attribution: '¬© Vlaanderen',
        opacity: 1.0,
        pane: 'overlayPaneTop',
        bounds: ferrarisBounds, // restrict tile requests to layer extent
        noWrap: true,           // don‚Äôt repeat tiles outside world bounds
        continuousWorld: false  // prevent extra out-of-range requests
      }
    ).addTo(map);

    const grb = L.tileLayer('https://geo.api.vlaanderen.be/GRB/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=grb_bsk&STYLE=&TILEMATRIXSET=GoogleMapsVL&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png',
      { attribution: '¬© Vlaanderen GRB', opacity: 1.0, pane: 'overlayPaneTop' }
    );

    const hillshade = L.tileLayer('https://geo.api.vlaanderen.be/DHMV/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=DHMV_II_HILL_25cm&STYLE=&TILEMATRIXSET=GoogleMapsVL&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=image/png',
      { attribution: '¬© Vlaanderen DHMV II', opacity: 1.0, pane: 'overlayPaneTop' }
    );


    const dhmvBounds = [
      [50.64, 2.52],   // southwest (lat, lng)
      [51.51, 5.94]    // northeast (lat, lng)
    ];

    const dhmv = L.tileLayer.wms(
      'https://geo.api.vlaanderen.be/DHMV/wms',
      {
        layers: 'DHMVII_DTM_1m',  // kies eventueel 'DHMVII_DSM_1m' of andere
        format: 'image/png',
        transparent: true,
        attribution: '¬© Vlaanderen',
        pane: 'overlayPaneTop',
        bounds: dhmvBounds,
        noWrap: true,
        continuousWorld: false,
        version: '1.3.0'
      }
    );




    map.zoomControl.setPosition('bottomright');

    const geocoder = L.Control.geocoder({ defaultMarkGeocode: true, placeholder: 'Search location...', errorMessage: 'Not found' })
      .on('markgeocode', function (e) { map.setView(e.geocode.center, 16); })
      .addTo(map);



    const drawingManager = new DrawingManager(map);
    const favManager = new FavoriteManager(map, drawingManager, document.getElementById('favoritesList'));
    UIManager.init({ favManager, drawingManager });

    const shared = ShareManager.loadSharedFavorite();
    if (shared) {
      drawingManager.loadGeoJSON(shared.shapes);
      map.setView(shared.center, shared.zoom);

      // optional: show banner: "This is a shared view, save it?"
    }

    // Overlay toggles

    document.getElementById('ferrarisToggle').addEventListener('change', e => e.target.checked ? ferraris.addTo(map) : map.removeLayer(ferraris));
    document.getElementById('grbToggle').addEventListener('change', e => e.target.checked ? grb.addTo(map) : map.removeLayer(grb));
    document.getElementById('hillshadeToggle').addEventListener('change', e => e.target.checked ? hillshade.addTo(map) : map.removeLayer(hillshade));
    document.getElementById('dhmvToggle').addEventListener('change', e => e.target.checked ? dhmv.addTo(map) : map.removeLayer(dhmv));

    document.getElementById('opacitySliderFerraris').addEventListener('input', e => ferraris.setOpacity(e.target.value));
    document.getElementById('opacitySliderGRB').addEventListener('input', e => grb.setOpacity(e.target.value));
    document.getElementById('opacitySliderHillshade').addEventListener('input', e => hillshade.setOpacity(e.target.value));
    document.getElementById('opacitySliderDhmv').addEventListener('input', e => dhmv.setOpacity(e.target.value));

    // Auto-pan logic
    let userMarker = null, autoPan = false;
    const autoPanToggle = document.getElementById('autoPanToggle');
    autoPanToggle.addEventListener('change', e => autoPan = e.target.checked);

    const userMarkerController = new UserLocationMarker(map);
    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(
        pos => {
          const { latitude, longitude } = pos.coords;
          userMarkerController.updatePosition(latitude, longitude);

          if (autoPan) map.setView([latitude, longitude]);
        },
        err => console.warn(err),
        { enableHighAccuracy: true, maximumAge: 1000 }
      );
    }

    const locateButton = L.control({ position: 'topright' });
    locateButton.onAdd = map => {
      const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
      div.innerHTML = `
    <a href="#" title="Go to my location" style="
      display: block;
      line-height: 26px; /* match Leaflet button height */
      text-align: center;
      text-decoration: none;
      color: inherit;
    ">
      <span class="material-icons" style="vertical-align: middle; font-size: 20px;">gps_fixed</span>
    </a>
  `;
      div.onclick = () => {
        if (userMarkerController.lastPosition) {
          map.setView(userMarkerController.lastPosition, 16);
        } else {
          alert("Location not available yet");
        }
      };
      return div;
    };
    locateButton.addTo(map);

    // Service Worker registration
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('https://piecesnbits.github.io/zoekmap/sw.js')
        .then(() => console.log('Service Worker registered'))
        .catch(err => console.error('Service Worker registration failed:', err));
    }
  </script>
</body>

</html>